# Поисковый движок для корпоративного портала

## Описание проекта

Это консольное приложение - поисковый движок, который осуществляет поиск по набору документов. Аналог поисковой строки Яндекса или Google, но для локального использования.

## Технологии

- **Язык**: C++20
- **Библиотеки**:
  - `nlohmann/json` - для работы с JSON файлами
  - `Google Test` - для модульного тестирования
- **Система сборки**: CMake 3.15+
- **Платформы**: Linux, Windows, macOS (кроссплатформенный)
- **IDE**: CLion, Visual Studio, Qt Creator, или любой редактор с поддержкой CMake

## Структура проекта

```
search_engine_1/
├── include/              # Заголовочные файлы
│   ├── ConverterJSON.h  # Класс для работы с JSON
│   ├── InvertedIndex.h  # Класс инвертированного индекса
│   └── SearchServer.h   # Класс поискового сервера
├── src/                 # Исходные файлы
│   ├── ConverterJSON.cpp
│   ├── InvertedIndex.cpp
│   ├── SearchServer.cpp
│   └── main.cpp         # Главная функция
├── tests/               # Тесты
│   ├── test_inverted.cpp
│   ├── test_search_server.cpp
│   └── test_main.cpp
├── resources/           # Тестовые документы
│   ├── file001.txt
│   ├── file002.txt
│   └── file003.txt
├── config.json          # Конфигурация
├── requests.json        # Поисковые запросы
└── answers.json         # Результаты поиска (создается автоматически)
```

## Детальное описание этапов реализации

### Этап 1: Подготовка

**Цель**: Подготовить проект и необходимые библиотеки.

**Что было сделано**:
- Создан проект в CLion
- Подключена библиотека `nlohmann/json` через CMake FetchContent
- Подключена библиотека `Google Test` для тестирования

### Этап 2: Класс ConverterJSON

**Цель**: Реализовать класс для работы с JSON файлами.

**Функциональность**:

1. **`GetResponseLimit()`** - читает максимальное количество ответов из `config.json`
   - Проверяет наличие файла (выбрасывает исключение, если файл отсутствует)
   - Проверяет наличие поля `config` (выбрасывает исключение, если поле пустое)
   - Возвращает значение `max_responses` или 5 по умолчанию

2. **`GetTextDocuments()`** - читает содержимое документов из файлов, указанных в `config.json`
   - Читает список путей к файлам из поля `files`
   - Для каждого файла читает его содержимое
   - Если файл не найден, выводит предупреждение, но не прерывает выполнение
   - Возвращает вектор строк с содержимым документов

3. **`GetRequests()`** - читает поисковые запросы из `requests.json`
   - Читает массив запросов из поля `requests`
   - Возвращает вектор строк с запросами

4. **`putAnswers()`** - записывает результаты поиска в `answers.json`
   - Формирует JSON структуру согласно спецификации
   - Для каждого запроса создает запись с идентификатором `request001`, `request002` и т.д.
   - Если документы найдены (`result: "true"`), добавляет информацию о релевантности
   - Если документов не найдено (`result: "false"`), записывает только результат

**Формат файлов**:

- **config.json**:
```json
{
  "config": {
    "name": "SearchEngine",
    "version": "1.0.0",
    "max_responses": 5
  },
  "files": [
    "resources/file001.txt",
    "resources/file002.txt",
    "resources/file003.txt"
  ]
}
```

- **requests.json**:
```json
{
  "requests": [
    "some words",
    "another query"
  ]
}
```

- **answers.json** (создается автоматически):
```json
{
  "answers": {
    "request001": {
      "result": "true",
      "relevance": [
        {"docid": 0, "rank": 0.989},
        {"docid": 1, "rank": 0.897}
      ]
    }
  }
}
```

### Этап 3: Система тестирования

**Цель**: Подключить Google Test для модульного тестирования.

**Что было сделано**:
- Настроен CMakeLists.txt для подключения Google Test
- Созданы тесты для `InvertedIndex` и `SearchServer`
- Тесты автоматически запускаются при сборке проекта

### Этап 4: Инвертированный индекс (InvertedIndex)

**Цель**: Реализовать систему индексации документов.

**Что такое инвертированный индекс?**

Инвертированный индекс - это структура данных, которая для каждого слова хранит список документов, в которых оно встречается, и количество вхождений.

**Пример**:
```
Документ 0: "milk sugar salt"
Документ 1: "milk a milk b milk c milk d"

Индекс:
"milk" -> [{doc_id: 0, count: 1}, {doc_id: 1, count: 4}]
"sugar" -> [{doc_id: 0, count: 1}]
"salt" -> [{doc_id: 0, count: 1}]
"a" -> [{doc_id: 1, count: 1}]
...
```

**Реализация**:

1. **`UpdateDocumentBase()`** - обновляет базу документов и строит индекс
   - Сохраняет тексты документов в вектор `docs`
   - Для каждого документа в **отдельном потоке**:
     - Разбивает текст на слова (разделитель - пробелы)
     - Подсчитывает частоту каждого слова в документе
     - Добавляет информацию в `freq_dictionary` с синхронизацией через мьютекс
   - Многопоточность ускоряет индексацию больших объемов данных

2. **`GetWordCount()`** - возвращает информацию о вхождениях слова
   - Ищет слово в `freq_dictionary`
   - Возвращает вектор `Entry` с `doc_id` и `count` для каждого документа

**Структуры данных**:
- `std::vector<std::string> docs` - хранит тексты документов
- `std::map<std::string, std::vector<Entry>> freq_dictionary` - частотный словарь
- `struct Entry { size_t doc_id, count; }` - запись о вхождении слова в документ

### Этап 5: Поисковый сервер (SearchServer)

**Цель**: Реализовать систему поиска и расчета релевантности.

**Алгоритм поиска**:

1. **Разбиение запроса на слова**
   - Запрос разбивается на отдельные слова по пробелам

2. **Формирование списка уникальных слов**
   - Удаляются дубликаты слов из запроса

3. **Сортировка слов по частоте**
   - Слова сортируются по возрастанию общей частоты встречаемости
   - Редкие слова обрабатываются первыми (это ускоряет поиск)

4. **Поиск документов**
   - Начинаем с первого (самого редкого) слова
   - Находим все документы, содержащие это слово
   - Для каждого следующего слова оставляем только те документы, которые содержат и предыдущие, и текущее слово
   - Если документов не осталось, возвращаем пустой результат

5. **Расчет релевантности**
   - **Абсолютная релевантность** = сумма всех `count` для всех слов запроса в документе
   - **Относительная релевантность** = абсолютная релевантность / максимальная абсолютная релевантность
   - Это нормализует значения от 0 до 1

6. **Сортировка результатов**
   - Документы сортируются по убыванию релевантности
   - Если релевантность одинаковая, сортируются по `doc_id`

**Пример расчета релевантности**:

Запрос: "лошадь бегает"

| Документ | Частота "лошадь" | Частота "бегает" | Абсолютная релевантность | Относительная релевантность |
|----------|------------------|------------------|-------------------------|----------------------------|
| 1        | 4                | 3                | 7                        | 0.7 (7/10)                 |
| 2        | 1                | 2                | 3                        | 0.3 (3/10)                 |
| 3        | 5                | 5                | 10                       | 1.0 (10/10)                |

### Этап 6: Главная функция (main.cpp)

**Алгоритм работы программы**:

1. Вывод информации о запуске ("Starting...")
2. Чтение конфигурации из `config.json`
   - Вывод названия движка
   - Получение максимального количества ответов
3. Загрузка документов
   - Чтение содержимого всех файлов из `config.json`
   - Вывод количества загруженных документов
4. Построение индекса
   - Создание объекта `InvertedIndex`
   - Вызов `UpdateDocumentBase()` для индексации
5. Загрузка запросов
   - Чтение запросов из `requests.json`
6. Выполнение поиска
   - Создание объекта `SearchServer`
   - Вызов метода `search()` для каждого запроса
   - Ограничение количества результатов согласно `max_responses`
7. Сохранение результатов
   - Преобразование результатов в формат для JSON
   - Запись в `answers.json` через `putAnswers()`

## Запуск проекта

### Требования

- **CMake** версии 3.15 или выше (рекомендуется 3.20+)
- **Компилятор C++** с поддержкой C++20:
  - Linux: GCC 10+ или Clang 12+
  - Windows: MSVC 2019+ или MinGW-w64
  - macOS: Clang 12+ (Xcode 13+)
- **Git** (для загрузки зависимостей через CMake FetchContent)

### Сборка проекта

#### Linux / macOS

```bash
# Создаем директорию для сборки
mkdir -p build
cd build

# Генерируем файлы сборки
cmake ..

# Собираем проект
cmake --build .

# Или используя make напрямую (если используется генератор Makefiles)
make
```

#### Windows

```bash
# В PowerShell или Command Prompt
mkdir build
cd build
cmake ..
cmake --build .
```

Или через Visual Studio:
```bash
cmake .. -G "Visual Studio 17 2022"
# Затем откройте solution файл в Visual Studio
```

### Запуск приложения

**Важно**: Убедитесь, что файлы `config.json` и `requests.json` находятся в той же директории, что и исполняемый файл, или в корне проекта.

#### Linux / macOS

```bash
# Если собирали в директории build/
cd build
./search_engine_1

# Или если исполняемый файл в корне проекта
./search_engine_1
```

#### Windows

```bash
# В PowerShell
.\search_engine_1.exe

# В Command Prompt
search_engine_1.exe
```

### Запуск тестов

#### Linux / macOS

```bash
cd build
ctest

# Или с подробным выводом
ctest --verbose

# Или запуск конкретного теста
./search_engine_1 --gtest_filter=TestCaseInvertedIndex.*
```

#### Windows

```bash
cd build
ctest
```

Или через CLion: правый клик на тесте → Run

### Структура файлов для запуска

Убедитесь, что структура файлов выглядит так:

```
search_engine_1/
├── config.json          # Должен быть в корне или рядом с исполняемым файлом
├── requests.json        # Должен быть в корне или рядом с исполняемым файлом
├── resources/           # Директория с документами
│   ├── file001.txt
│   ├── file002.txt
│   └── file003.txt
└── build/              # Директория сборки (или cmake-build-debug)
    └── search_engine_1  # Исполняемый файл (или search_engine_1.exe на Windows)
```

**Примечание**: После сборки файл `answers.json` будет создан автоматически в той же директории, где запускается программа.

## Кроссплатформенность

Проект полностью кроссплатформенный и работает на:

### ✅ Linux

**Требования**:
- GCC 10+ или Clang 12+ с поддержкой C++20
- CMake 3.15+
- Стандартная библиотека pthread (обычно входит в систему)

**Установка зависимостей** (Ubuntu/Debian):
```bash
sudo apt-get update
sudo apt-get install build-essential cmake git
```

**Установка зависимостей** (Fedora/RHEL):
```bash
sudo dnf install gcc-c++ cmake git
```

**Установка зависимостей** (Arch Linux):
```bash
sudo pacman -S base-devel cmake git
```

**Сборка**:
```bash
mkdir build && cd build
cmake ..
make
./search_engine_1
```

### ✅ Windows

**Требования**:
- Visual Studio 2019+ с поддержкой C++20, или
- MinGW-w64 с GCC 10+
- CMake 3.15+

**Сборка с Visual Studio**:
```bash
mkdir build && cd build
cmake .. -G "Visual Studio 17 2022"
cmake --build . --config Release
```

**Сборка с MinGW**:
```bash
mkdir build && cd build
cmake .. -G "MinGW Makefiles"
cmake --build .
```

### ✅ macOS

**Требования**:
- Xcode 13+ (Clang 12+)
- CMake 3.15+ (можно установить через Homebrew)

**Установка CMake** (если не установлен):
```bash
brew install cmake
```

**Сборка**:
```bash
mkdir build && cd build
cmake ..
make
./search_engine_1
```

### Важные замечания

1. **Пути к файлам**: Все пути к файлам (`config.json`, `requests.json`, `answers.json`) относительные и работают одинаково на всех платформах.

2. **Разделители путей**: В коде используются относительные пути, поэтому проблемы с `/` vs `\` не возникают.

3. **Многопоточность**: Используется стандартная библиотека `std::thread`, которая работает на всех платформах.

4. **Зависимости**: Все зависимости (`nlohmann/json`, `googletest`) загружаются автоматически через CMake FetchContent, не требуют ручной установки.

5. **Кодировка файлов**: JSON файлы должны быть в UTF-8 (стандарт для JSON).

### Возможные проблемы и решения

**Проблема**: "CMake version is too old"
- **Решение**: Обновите CMake до версии 3.15 или выше

**Проблема**: "C++20 not supported"
- **Решение**: Обновите компилятор (GCC 10+, Clang 12+, MSVC 2019+)

**Проблема**: "config.json not found"
- **Решение**: Убедитесь, что файл находится в той же директории, где запускается программа, или скопируйте его в директорию сборки

**Проблема**: На Linux - ошибки компиляции с pthread
- **Решение**: Установите `libpthread-dev` (Ubuntu/Debian) или `glibc-devel` (Fedora)

## Требования к файлам

### config.json
- Должен содержать поле `config` с информацией о движке
- Поле `files` должно содержать пути к файлам для индексации
- Если файл не найден, выводится предупреждение, но программа продолжает работу

### requests.json
- Должен содержать поле `requests` с массивом поисковых запросов
- Каждый запрос - строка с словами, разделенными пробелами

### Документы
- Каждый документ содержит не более 1000 слов
- Максимальная длина слова - 100 символов
- Слова состоят из строчных латинских букв
- Слова разделены одним или несколькими пробелами

## Особенности реализации

1. **Многопоточность**: Индексация документов выполняется в отдельных потоках для ускорения работы
2. **Обработка ошибок**: Все критические ошибки обрабатываются с выбросом исключений
3. **Валидация данных**: Проверка наличия файлов и корректности JSON
4. **Нормализация релевантности**: Релевантность нормализуется от 0 до 1 для удобства сравнения
5. **Кроссплатформенность**: Проект работает на Linux, Windows и macOS без изменений кода

## Тестирование

Проект включает модульные тесты для проверки:
- Корректности построения инвертированного индекса
- Правильности расчета релевантности
- Обработки граничных случаев (пустые запросы, отсутствующие слова)

## Автор

Владимир - Разработчик на C++ с нуля

## Лицензия

Этот проект создан в рамках учебного курса.

