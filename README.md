# Поисковый движок для корпоративного портала

## Описание проекта

Это консольное приложение - поисковый движок, который осуществляет поиск по набору документов. Аналог поисковой строки Яндекса или Google, но для локального использования.

## Технологии

- **Язык**: C++20
- **Библиотеки**:
  - `nlohmann/json` - для работы с JSON файлами
  - `Google Test` - для модульного тестирования
- **Система сборки**: CMake 3.15+
- **Платформы**: Linux, Windows, macOS (кроссплатформенный)
- **IDE**: CLion, Visual Studio, Qt Creator, или любой редактор с поддержкой CMake

## Структура проекта

```
search_engine_1/
├── include/              # Заголовочные файлы
│   ├── ConverterJSON.h  # Класс для работы с JSON
│   ├── InvertedIndex.h  # Класс инвертированного индекса
│   └── SearchServer.h   # Класс поискового сервера
├── src/                 # Исходные файлы
│   ├── ConverterJSON.cpp
│   ├── InvertedIndex.cpp
│   ├── SearchServer.cpp
│   └── main.cpp         # Главная функция
├── tests/               # Тесты
│   ├── test_inverted.cpp
│   ├── test_search_server.cpp
│   └── test_main.cpp
├── resources/           # Тестовые документы
│   ├── file001.txt
│   ├── file002.txt
│   └── file003.txt
├── config/              # Конфигурационные файлы
│   ├── config.json      # Конфигурация
│   ├── request.json     # Поисковые запросы
│   └── answers.json     # Результаты поиска (создается автоматически)
└── CMakeLists.txt       # Файл конфигурации CMake
```

## Детальное описание этапов реализации

### Этап 1: Подготовка

**Цель**: Подготовить проект и необходимые библиотеки.

**Что было сделано**:
- Создан проект в CLion
- Настроен CMake для автоматической загрузки зависимостей (nlohmann/json, Google Test)
- Создана структура директорий (include, src, tests, resources, config)

### Этап 2: Реализация ConverterJSON

**Цель**: Создать класс для работы с JSON файлами.

**Реализованные методы**:
- `GetTextDocuments()` - чтение списка документов из config.json и загрузка их содержимого
- `GetResponseLimit()` - получение максимального количества результатов поиска
- `GetRequests()` - чтение поисковых запросов из request.json
- `putAnswers()` - запись результатов поиска в answers.json

**Особенности реализации**:
- Обработка ошибок (отсутствие файлов, пустые конфиги)
- Поддержка как "max_responses", так и "max_response" в конфиге
- Корректный формат вывода: один документ записывается напрямую, несколько - в массиве relevance
- Все строковые константы вынесены в namespace для избежания дублирования

### Этап 3: Реализация InvertedIndex

**Цель**: Создать инвертированный индекс для быстрого поиска слов в документах.

**Реализованные методы**:
- `UpdateDocumentBase()` - многопоточная индексация документов
- `GetWordCount()` - получение информации о количестве вхождений слова в документах

**Особенности реализации**:
- Многопоточная обработка документов с использованием `std::thread`
- Синхронизация доступа к общему словарю через `std::mutex`
- Нормализация текста (приведение к нижнему регистру, удаление знаков препинания)
- Подсчет частоты вхождений каждого слова в каждом документе

**Алгоритм индексации**:
1. Разбиение документа на слова
2. Нормализация каждого слова
3. Подсчет частоты вхождений
4. Сохранение в структуре `freq_dictionary[word] = vector<Entry>`

### Этап 4: Реализация SearchServer

**Цель**: Создать поисковый сервер, который находит релевантные документы по запросам.

**Реализованные методы**:
- `search()` - поиск документов по запросам с расчетом релевантности

**Алгоритм поиска**:
1. Разбиение запроса на слова
2. Поиск документов, содержащих все слова запроса
3. Расчет абсолютной релевантности для каждого документа:
   ```
   absolute_relevance = sum(word_count_in_doc / total_words_in_doc)
   ```
4. Расчет относительной релевантности:
   ```
   relative_relevance = absolute_relevance / max_absolute_relevance
   ```
5. Сортировка результатов по убыванию релевантности

**Особенности реализации**:
- Поиск только документов, содержащих все слова запроса
- Расчет релевантности на основе частоты слов
- Сортировка результатов по убыванию релевантности
- Возврат результатов в формате `vector<vector<RelativeIndex>>`

### Этап 5: Реализация main.cpp

**Цель**: Создать главную функцию, которая объединяет все компоненты.

**Логика работы**:
1. Инициализация ConverterJSON
2. Загрузка документов из config.json
3. Построение инвертированного индекса
4. Загрузка поисковых запросов из request.json
5. Выполнение поиска
6. Сохранение результатов в answers.json

**Обработка ошибок**:
- Проверка наличия конфигурационных файлов
- Проверка наличия документов
- Обработка исключений с выводом понятных сообщений об ошибках

### Этап 6: Тестирование

**Цель**: Убедиться, что все компоненты работают корректно.

**Реализованные тесты**:
- `test_inverted.cpp` - тесты для InvertedIndex
  - TestBasic - проверка базовой функциональности
  - TestBasic2 - проверка с опечаткой в слове
  - TestInvertedIndexFunctionality - комплексный тест
- `test_search_server.cpp` - тесты для SearchServer
  - SimpleTest - простой тест поиска
  - Top5Test - проверка ограничения количества результатов

## Запуск проекта

### Требования

- **CMake** версии 3.15 или выше (рекомендуется 3.20+)
- **Компилятор C++** с поддержкой C++20:
  - Linux: GCC 10+ или Clang 12+
  - Windows: MSVC 2019+ или MinGW-w64
  - macOS: Clang 12+ (Xcode 13+)
- **Git** (для загрузки зависимостей через CMake FetchContent)

### Сборка проекта

#### Linux / macOS

```bash
# Создаем директорию для сборки
mkdir -p build
cd build

# Генерируем файлы сборки
cmake ..

# Собираем проект
cmake --build .

# Или используя make напрямую (если используется генератор Makefiles)
make
```

#### Windows

```bash
# В PowerShell или Command Prompt
mkdir build
cd build
cmake ..
cmake --build .
```

Или через Visual Studio:
```bash
# Генерируем проект для Visual Studio
cmake .. -G "Visual Studio 17 2022"

# Открываем search_engine_1.sln в Visual Studio и собираем
```

### Запуск программы

После сборки выполните:

**Linux/macOS:**
```bash
./build/src/search_engine_1
```

**Windows:**
```cmd
build\src\Debug\search_engine_1.exe
```

Или если вы используете CLion, просто запустите конфигурацию `search_engine_1`.

### Запуск тестов

**Linux/macOS:**
```bash
cd build
ctest
# или
./tests/search_engine_tests
```

**Windows:**
```cmd
cd build
ctest
# или
tests\Debug\search_engine_tests.exe
```

## Формат конфигурационных файлов

### config.json

```json
{
  "config": {
    "name": "SearchEngine",
    "version": "1.0.0",
    "max_responses": 5
  },
  "files": [
    "resources/file001.txt",
    "resources/file002.txt",
    "resources/file003.txt"
  ]
}
```

### request.json

```json
{
  "requests": [
    "C++",
    "another search query"
  ]
}
```

### answers.json (создается автоматически)

**Формат для одного результата:**
```json
{
  "answers": {
    "request001": {
      "result": "true",
      "docid": 0,
      "rank": 0.769
    }
  }
}
```

**Формат для нескольких результатов:**
```json
{
  "answers": {
    "request001": {
      "result": "true",
      "relevance": [
        {"docid": 0, "rank": 0.989},
        {"docid": 1, "rank": 0.897}
      ]
    }
  }
}
```

## Кроссплатформенность

Проект полностью кроссплатформенный и работает на:
- **Linux** (Ubuntu, Debian, Fedora, и др.)
- **Windows** (10, 11)
- **macOS** (10.15+)

### Особенности для разных платформ

**Linux:**
- Требуется установленный компилятор: `sudo apt-get install g++` (Ubuntu/Debian)
- CMake можно установить через пакетный менеджер: `sudo apt-get install cmake`

**Windows:**
- Рекомендуется использовать Visual Studio 2019+ или MinGW-w64
- CMake можно скачать с официального сайта или установить через Visual Studio Installer

**macOS:**
- Требуется Xcode Command Line Tools: `xcode-select --install`
- CMake можно установить через Homebrew: `brew install cmake`

## Возможные проблемы и решения

### Проблема: "config file is missing"

**Решение**: Убедитесь, что файл `config/config.json` существует в корне проекта.

### Проблема: "No documents found"

**Решение**: Проверьте, что в `config.json` указаны правильные пути к файлам в директории `resources/`.

### Проблема: Ошибки компиляции с C++20

**Решение**: Убедитесь, что ваш компилятор поддерживает C++20. Для старых версий может потребоваться обновление.

### Проблема: Зависимости не загружаются

**Решение**: Проверьте подключение к интернету. CMake использует FetchContent для автоматической загрузки nlohmann/json и Google Test.

## Архитектура проекта

Проект состоит из трех основных классов:

1. **ConverterJSON** - отвечает за работу с JSON файлами (конфигурация, запросы, ответы)
2. **InvertedIndex** - создает и хранит инвертированный индекс документов
3. **SearchServer** - выполняет поиск по индексу и рассчитывает релевантность

Все классы независимы друг от друга и могут быть легко протестированы отдельно.

## Оптимизации

- **Многопоточность**: Индексация документов выполняется в отдельных потоках для ускорения процесса
- **Передача по ссылке**: Большие объекты передаются по константной ссылке для избежания копирования
- **Константы**: Все строковые литералы вынесены в константы для централизованного управления

## Лицензия

Это учебный проект, созданный в рамках курса "Разработчик на C++ с нуля".

## Автор

Проект создан в рамках финальной работы курса.

