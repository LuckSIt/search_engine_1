# Поисковый движок для корпоративного портала

## Описание проекта

Это консольное приложение - поисковый движок, который осуществляет поиск по набору документов. Аналог поисковой строки Яндекса или Google, но для локального использования.

## Технологии

- **Язык**: C++20
- **Библиотеки**:
  - `nlohmann/json` - для работы с JSON файлами
  - `Google Test` - для модульного тестирования
- **Система сборки**: CMake
- **IDE**: CLion (рекомендуется)

## Структура проекта

```
search_engine_1/
├── include/              # Заголовочные файлы
│   ├── ConverterJSON.h  # Класс для работы с JSON
│   ├── InvertedIndex.h  # Класс инвертированного индекса
│   └── SearchServer.h   # Класс поискового сервера
├── src/                 # Исходные файлы
│   ├── ConverterJSON.cpp
│   ├── InvertedIndex.cpp
│   ├── SearchServer.cpp
│   └── main.cpp         # Главная функция
├── tests/               # Тесты
│   ├── test_inverted.cpp
│   ├── test_search_server.cpp
│   └── test_main.cpp
├── resources/           # Тестовые документы
│   ├── file001.txt
│   ├── file002.txt
│   └── file003.txt
├── config.json          # Конфигурация
├── requests.json        # Поисковые запросы
└── answers.json         # Результаты поиска (создается автоматически)
```

## Детальное описание этапов реализации

### Этап 1: Подготовка

**Цель**: Подготовить проект и необходимые библиотеки.

**Что было сделано**:
- Создан проект в CLion
- Подключена библиотека `nlohmann/json` через CMake FetchContent
- Подключена библиотека `Google Test` для тестирования

### Этап 2: Класс ConverterJSON

**Цель**: Реализовать класс для работы с JSON файлами.

**Функциональность**:

1. **`GetResponseLimit()`** - читает максимальное количество ответов из `config.json`
   - Проверяет наличие файла (выбрасывает исключение, если файл отсутствует)
   - Проверяет наличие поля `config` (выбрасывает исключение, если поле пустое)
   - Возвращает значение `max_responses` или 5 по умолчанию

2. **`GetTextDocuments()`** - читает содержимое документов из файлов, указанных в `config.json`
   - Читает список путей к файлам из поля `files`
   - Для каждого файла читает его содержимое
   - Если файл не найден, выводит предупреждение, но не прерывает выполнение
   - Возвращает вектор строк с содержимым документов

3. **`GetRequests()`** - читает поисковые запросы из `requests.json`
   - Читает массив запросов из поля `requests`
   - Возвращает вектор строк с запросами

4. **`putAnswers()`** - записывает результаты поиска в `answers.json`
   - Формирует JSON структуру согласно спецификации
   - Для каждого запроса создает запись с идентификатором `request001`, `request002` и т.д.
   - Если документы найдены (`result: "true"`), добавляет информацию о релевантности
   - Если документов не найдено (`result: "false"`), записывает только результат

**Формат файлов**:

- **config.json**:
```json
{
  "config": {
    "name": "SearchEngine",
    "version": "1.0.0",
    "max_responses": 5
  },
  "files": [
    "resources/file001.txt",
    "resources/file002.txt",
    "resources/file003.txt"
  ]
}
```

- **requests.json**:
```json
{
  "requests": [
    "some words",
    "another query"
  ]
}
```

- **answers.json** (создается автоматически):
```json
{
  "answers": {
    "request001": {
      "result": "true",
      "relevance": [
        {"docid": 0, "rank": 0.989},
        {"docid": 1, "rank": 0.897}
      ]
    }
  }
}
```

### Этап 3: Система тестирования

**Цель**: Подключить Google Test для модульного тестирования.

**Что было сделано**:
- Настроен CMakeLists.txt для подключения Google Test
- Созданы тесты для `InvertedIndex` и `SearchServer`
- Тесты автоматически запускаются при сборке проекта

### Этап 4: Инвертированный индекс (InvertedIndex)

**Цель**: Реализовать систему индексации документов.

**Что такое инвертированный индекс?**

Инвертированный индекс - это структура данных, которая для каждого слова хранит список документов, в которых оно встречается, и количество вхождений.

**Пример**:
```
Документ 0: "milk sugar salt"
Документ 1: "milk a milk b milk c milk d"

Индекс:
"milk" -> [{doc_id: 0, count: 1}, {doc_id: 1, count: 4}]
"sugar" -> [{doc_id: 0, count: 1}]
"salt" -> [{doc_id: 0, count: 1}]
"a" -> [{doc_id: 1, count: 1}]
...
```

**Реализация**:

1. **`UpdateDocumentBase()`** - обновляет базу документов и строит индекс
   - Сохраняет тексты документов в вектор `docs`
   - Для каждого документа в **отдельном потоке**:
     - Разбивает текст на слова (разделитель - пробелы)
     - Подсчитывает частоту каждого слова в документе
     - Добавляет информацию в `freq_dictionary` с синхронизацией через мьютекс
   - Многопоточность ускоряет индексацию больших объемов данных

2. **`GetWordCount()`** - возвращает информацию о вхождениях слова
   - Ищет слово в `freq_dictionary`
   - Возвращает вектор `Entry` с `doc_id` и `count` для каждого документа

**Структуры данных**:
- `std::vector<std::string> docs` - хранит тексты документов
- `std::map<std::string, std::vector<Entry>> freq_dictionary` - частотный словарь
- `struct Entry { size_t doc_id, count; }` - запись о вхождении слова в документ

### Этап 5: Поисковый сервер (SearchServer)

**Цель**: Реализовать систему поиска и расчета релевантности.

**Алгоритм поиска**:

1. **Разбиение запроса на слова**
   - Запрос разбивается на отдельные слова по пробелам

2. **Формирование списка уникальных слов**
   - Удаляются дубликаты слов из запроса

3. **Сортировка слов по частоте**
   - Слова сортируются по возрастанию общей частоты встречаемости
   - Редкие слова обрабатываются первыми (это ускоряет поиск)

4. **Поиск документов**
   - Начинаем с первого (самого редкого) слова
   - Находим все документы, содержащие это слово
   - Для каждого следующего слова оставляем только те документы, которые содержат и предыдущие, и текущее слово
   - Если документов не осталось, возвращаем пустой результат

5. **Расчет релевантности**
   - **Абсолютная релевантность** = сумма всех `count` для всех слов запроса в документе
   - **Относительная релевантность** = абсолютная релевантность / максимальная абсолютная релевантность
   - Это нормализует значения от 0 до 1

6. **Сортировка результатов**
   - Документы сортируются по убыванию релевантности
   - Если релевантность одинаковая, сортируются по `doc_id`

**Пример расчета релевантности**:

Запрос: "лошадь бегает"

| Документ | Частота "лошадь" | Частота "бегает" | Абсолютная релевантность | Относительная релевантность |
|----------|------------------|------------------|-------------------------|----------------------------|
| 1        | 4                | 3                | 7                        | 0.7 (7/10)                 |
| 2        | 1                | 2                | 3                        | 0.3 (3/10)                 |
| 3        | 5                | 5                | 10                       | 1.0 (10/10)                |

### Этап 6: Главная функция (main.cpp)

**Алгоритм работы программы**:

1. Вывод информации о запуске ("Starting...")
2. Чтение конфигурации из `config.json`
   - Вывод названия движка
   - Получение максимального количества ответов
3. Загрузка документов
   - Чтение содержимого всех файлов из `config.json`
   - Вывод количества загруженных документов
4. Построение индекса
   - Создание объекта `InvertedIndex`
   - Вызов `UpdateDocumentBase()` для индексации
5. Загрузка запросов
   - Чтение запросов из `requests.json`
6. Выполнение поиска
   - Создание объекта `SearchServer`
   - Вызов метода `search()` для каждого запроса
   - Ограничение количества результатов согласно `max_responses`
7. Сохранение результатов
   - Преобразование результатов в формат для JSON
   - Запись в `answers.json` через `putAnswers()`

## Запуск проекта

### Сборка проекта

```bash
cd cmake-build-debug
cmake ..
cmake --build .
```

### Запуск приложения

```bash
./search_engine_1
```

Или в Windows:
```bash
.\search_engine_1.exe
```

### Запуск тестов

```bash
cd cmake-build-debug
ctest
```

Или через CLion: правый клик на тесте → Run

## Требования к файлам

### config.json
- Должен содержать поле `config` с информацией о движке
- Поле `files` должно содержать пути к файлам для индексации
- Если файл не найден, выводится предупреждение, но программа продолжает работу

### requests.json
- Должен содержать поле `requests` с массивом поисковых запросов
- Каждый запрос - строка с словами, разделенными пробелами

### Документы
- Каждый документ содержит не более 1000 слов
- Максимальная длина слова - 100 символов
- Слова состоят из строчных латинских букв
- Слова разделены одним или несколькими пробелами

## Особенности реализации

1. **Многопоточность**: Индексация документов выполняется в отдельных потоках для ускорения работы
2. **Обработка ошибок**: Все критические ошибки обрабатываются с выбросом исключений
3. **Валидация данных**: Проверка наличия файлов и корректности JSON
4. **Нормализация релевантности**: Релевантность нормализуется от 0 до 1 для удобства сравнения

## Тестирование

Проект включает модульные тесты для проверки:
- Корректности построения инвертированного индекса
- Правильности расчета релевантности
- Обработки граничных случаев (пустые запросы, отсутствующие слова)

## Автор

Владимир - Разработчик на C++ с нуля

## Лицензия

Этот проект создан в рамках учебного курса.

